-- Author: vincent.garonne@cern.ch
-- Date:

CREATE TABLE subscriptions_history (
	id RAW(16),
	name VARCHAR2(64 CHAR),
	filter VARCHAR2(2048 CHAR),
	replication_rules VARCHAR2(1024 CHAR),
	policyid INTEGER,
	state VARCHAR(8 CHAR),
	last_processed DATE,
	account VARCHAR2(255 CHAR),
	lifetime DATE,
	retroactive NUMBER(1),
	expired_at DATE,
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "SUBSCRIPTIONS_HISTORY_PK" PRIMARY KEY (id, updated_at),
	CONSTRAINT "SUBS_HISTORY_STATE_CHK" CHECK (state IN ('ACTIVE', 'INACTIVE', 'NEW', 'UPDATED', 'BROKEN')),
	CONSTRAINT "SUBS_HISTORY_RETROACTIVE_CHK" CHECK (retroactive IN (0, 1))
) PCTFREE 0;


CREATE TABLE mock_fts_transfers (
	transfer_id RAW(16),
	start_time DATE,
	last_modified DATE,
	state VARCHAR(13 CHAR),
	transfer_metadata VARCHAR2(4000 CHAR),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "MOCK_FTS_TRANSFERS_PK" PRIMARY KEY (transfer_id),
	CONSTRAINT "MOCK_FTS_TRANSFERS_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "MOCK_FTS_TRANSFERS_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL),
	CHECK (state IN ('SUBMITTED', 'READY', 'ACTIVE', 'FAILED', 'FINISHED', 'FINISHEDDIRTY', 'CANCELED'))
) PCTFREE 0;


CREATE TABLE identities (
	identity VARCHAR2(255 CHAR),
	type VARCHAR(8 CHAR),
	username VARCHAR2(255 CHAR),
	password VARCHAR2(255 CHAR),
	salt BLOB,
	email VARCHAR2(255 CHAR),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "IDENTITIES_PK" PRIMARY KEY (identity, type),
	CONSTRAINT "IDENTITIES_TYPE_NN" CHECK ("TYPE" IS NOT NULL),
	CONSTRAINT "IDENTITIES_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "IDENTITIES_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL),
	CONSTRAINT "IDENTITIES_TYPE_CHK" CHECK (type IN ('x509', 'gss', 'userpass'))
) PCTFREE 0;


CREATE TABLE rse_usage_history (
	rse_id RAW(16),
	source VARCHAR2(255 CHAR),
	used NUMBER(19),
	free NUMBER(19),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "RSE_USAGE_HISTORY_PK" PRIMARY KEY (rse_id, source, updated_at)
) PCTFREE 0;


CREATE TABLE rses (
	id RAW(16),
	rse VARCHAR2(255 CHAR),
	type VARCHAR(4 CHAR),
	prefix VARCHAR2(1024 CHAR),
	deterministic NUMBER(1),
	volatile NUMBER(1),
	updated_at DATE,
	created_at DATE,
	deleted NUMBER(1),
	deleted_at DATE,
	CONSTRAINT "RSES_PK" PRIMARY KEY (id),
	CONSTRAINT uq_rses_rse UNIQUE (rse),
	CONSTRAINT "RSES_RSE__NN" CHECK ("RSE" IS NOT NULL),
	CONSTRAINT "RSES_TYPE_NN" CHECK ("TYPE" IS NOT NULL),
	CONSTRAINT "RSES_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "RSES_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL),
	CONSTRAINT "RSES_DELETED_NN" CHECK (DELETED IS NOT NULL),
	CONSTRAINT "RSES_TYPE_CHK" CHECK (type IN ('disk', 'tape')),
	CONSTRAINT "RSE_DETERMINISTIC_CHK" CHECK (deterministic IN (0, 1)),
	CONSTRAINT "RSE_VOLATILE_CHK" CHECK (volatile IN (0, 1)),
	CONSTRAINT "RSES_DELETED_CHK" CHECK (deleted IN (0, 1))
) PCTFREE 0;


CREATE TABLE account_usage_history (
	account VARCHAR2(30 CHAR),
	rse_id RAW(16),
	name VARCHAR2(255 CHAR),
	value NUMBER(19),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "ACCOUNT_USAGE_HISTORY_PK" PRIMARY KEY (account, rse_id, name, updated_at)
) PCTFREE 0;


CREATE TABLE accounts (
	account VARCHAR2(30 CHAR),
	type VARCHAR(7 CHAR),
	status VARCHAR(9 CHAR),
	suspended_at DATE,
	deleted_at DATE,
	updated_at DATE,
	created_at DATE,
	deleted NUMBER(1),
	CONSTRAINT "ACCOUNTS_PK" PRIMARY KEY (account),
	CONSTRAINT "ACCOUNTS_TYPE_NN" CHECK ("TYPE" IS NOT NULL),
	CONSTRAINT "ACCOUNTS_STATUS_NN" CHECK ("STATUS" IS NOT NULL),
	CONSTRAINT "ACCOUNTS_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "ACCOUNTS_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL),
	CONSTRAINT "ACCOUNTS_DELETED_NN" CHECK (DELETED IS NOT NULL),
	CONSTRAINT "ACCOUNTS_TYPE_CHK" CHECK (type IN ('user', 'group', 'service')),
	CONSTRAINT "ACCOUNTS_STATUS_CHK" CHECK (status IN ('ACTIVE', 'DELETED', 'SUSPENDED')),
	CONSTRAINT "ACCOUNTS_DELETED_CHK" CHECK (deleted IN (0, 1))
) PCTFREE 0;


CREATE TABLE callbacks (
	id RAW(16),
	event_type VARCHAR2(1024 CHAR),
	payload VARCHAR2(4000 CHAR),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "CALLBACKS_PK" PRIMARY KEY (id),
	CONSTRAINT "CALLBACKS_EVENT_TYPE_NN" CHECK ("EVENT_TYPE" IS NOT NULL),
	CONSTRAINT "CALLBACKS_PAYLOAD_NN" CHECK ("PAYLOAD" IS NOT NULL),
	CONSTRAINT "CALLBACKS_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "CALLBACKS_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL)
) PCTFREE 0;


CREATE TABLE did_keys (
	key VARCHAR2(255 CHAR),
	key_type VARCHAR(10 CHAR),
	value_type VARCHAR2(255 CHAR),
	value_regexp VARCHAR2(255 CHAR),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "DID_KEYS_PK" PRIMARY KEY (key),
	CONSTRAINT "DID_KEYS_KEY_TYPE_NN" CHECK (key_type IS NOT NULL),
	CONSTRAINT "DID_KEYS_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "DID_KEYS_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL),
	CONSTRAINT "DID_KEYS_KEY_TYPE_CHK" CHECK (key_type IN ('all', 'collection', 'file', 'derived'))
) PCTFREE 0;


CREATE TABLE account_usage (
	account VARCHAR2(30 CHAR),
	rse_id RAW(16),
	name VARCHAR2(255 CHAR),
	value NUMBER(19),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "ACCOUNT_USAGE_PK" PRIMARY KEY (account, rse_id, name),
	CONSTRAINT "ACCOUNT_USAGE_ACCOUNT_FK" FOREIGN KEY(account) REFERENCES accounts (account),
	CONSTRAINT "ACCOUNT_USAGE_RSES_ID_FK" FOREIGN KEY(rse_id) REFERENCES rses (id),
	CONSTRAINT "ACCOUNT_USAGE_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "ACCOUNT_USAGE_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL)
) PCTFREE 0;


CREATE TABLE subscriptions (
	id RAW(16),
	name VARCHAR2(64 CHAR),
	filter VARCHAR2(2048 CHAR),
	replication_rules VARCHAR2(1024 CHAR),
	policyid INTEGER,
	state VARCHAR(8 CHAR),
	last_processed DATE,
	account VARCHAR2(255 CHAR),
	lifetime DATE,
	retroactive NUMBER(1),
	expired_at DATE,
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "SUBSCRIPTIONS_PK" PRIMARY KEY (id),
	CONSTRAINT uq_subscriptions_name UNIQUE (name, account),
	CONSTRAINT "SUBSCRIPTIONS_ACCOUNT_FK" FOREIGN KEY(account) REFERENCES accounts (account),
	CONSTRAINT "SUBSCRIPTIONS_RETROACTIVE_NN" CHECK ("RETROACTIVE" IS NOT NULL),
	CONSTRAINT "SUBSCRIPTIONS_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "SUBSCRIPTIONS_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL),
	CONSTRAINT "SUBSCRIPTIONS_STATE_CHK" CHECK (state IN ('ACTIVE', 'INACTIVE', 'NEW', 'UPDATED', 'BROKEN')),
	CONSTRAINT "SUBSCRIPTIONS_RETROACTIVE_CHK" CHECK (retroactive IN (0, 1))
) PCTFREE 0;


CREATE TABLE rse_usage (
	rse_id RAW(16),
	source VARCHAR2(255 CHAR),
	used NUMBER(19),
	free NUMBER(19),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "RSE_USAGE_PK" PRIMARY KEY (rse_id, source),
	CONSTRAINT "RSE_USAGE_RSE_ID_FK" FOREIGN KEY(rse_id) REFERENCES rses (id),
	CONSTRAINT "RSE_USAGE_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "RSE_USAGE_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL)
) PCTFREE 0;


CREATE TABLE rse_attr_map (
	rse_id RAW(16),
	key VARCHAR2(255 CHAR),
	value VARCHAR2(255 CHAR),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "RSE_ATTR_MAP_PK" PRIMARY KEY (rse_id, key),
	CONSTRAINT "RSE_ATTR_MAP_RSE_ID_FK" FOREIGN KEY(rse_id) REFERENCES rses (id),
	CONSTRAINT "RSE_ATTR_MAP_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "RSE_ATTR_MAP_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL)
) PCTFREE 0;


CREATE TABLE account_limits (
	account VARCHAR2(30 CHAR),
	rse_expression VARCHAR2(255 CHAR),
	name VARCHAR2(255 CHAR),
	value NUMBER(19),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "ACCOUNT_LIMITS_PK" PRIMARY KEY (account, rse_expression, name),
	CONSTRAINT "ACCOUNT_LIMITS_ACCOUNT_FK" FOREIGN KEY(account) REFERENCES accounts (account),
	CONSTRAINT "ACCOUNT_LIMITS_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "ACCOUNT_LIMITS_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL)
) PCTFREE 0;


CREATE TABLE rse_limits (
	rse_id RAW(16),
	name VARCHAR2(255 CHAR),
	value NUMBER(19),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "RSE_LIMITS_PK" PRIMARY KEY (rse_id, name),
	CONSTRAINT "RSE_LIMIT_RSE_ID_FK" FOREIGN KEY(rse_id) REFERENCES rses (id),
	CONSTRAINT "RSE_LIMITS_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "RSE_LIMITS_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL)
) PCTFREE 0;


CREATE TABLE rse_protocols (
	rse_id RAW(16),
	scheme VARCHAR2(255 CHAR),
	hostname VARCHAR2(255 CHAR),
	port INTEGER,
	prefix VARCHAR2(1024 CHAR),
	impl VARCHAR2(255 CHAR) NOT NULL,
	"read_LAN" INTEGER,
	"write_LAN" INTEGER,
	"delete_LAN" INTEGER,
	"read_WAN" INTEGER,
	"write_WAN" INTEGER,
	"delete_WAN" INTEGER,
	extended_attributes VARCHAR2(1024 CHAR),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "RSE_PROTOCOLS_PK" PRIMARY KEY (rse_id, scheme, hostname, port),
	CONSTRAINT "RSE_PROTOCOL_RSE_ID_FK" FOREIGN KEY(rse_id) REFERENCES rses (id),
	CONSTRAINT "RSE_PROTOCOLS_IMPL_NN" CHECK ("IMPL" IS NOT NULL),
	CONSTRAINT "RSE_PROTOCOLS_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "RSE_PROTOCOLS_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL)
) PCTFREE 0;


CREATE TABLE scopes (
	scope VARCHAR2(30 CHAR),
	account VARCHAR2(30 CHAR),
	is_default NUMBER(1),
	status VARCHAR(7 CHAR),
	closed_at DATE,
	deleted_at DATE,
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "SCOPES_PK" PRIMARY KEY (scope),
	CONSTRAINT "SCOPES_ACCOUNT_FK" FOREIGN KEY(account) REFERENCES accounts (account),
	CONSTRAINT "SCOPES_IS_DEFAULT_NN" CHECK (is_default IS NOT NULL),
	CONSTRAINT "SCOPES_STATUS_NN" CHECK (STATUS IS NOT NULL),
	CONSTRAINT "SCOPES_ACCOUNT_NN" CHECK (account IS NOT NULL),
	CONSTRAINT "SCOPES_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "SCOPES_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL),
	CONSTRAINT "SCOPES_DEFAULT_CHK" CHECK (is_default IN (0, 1)),
	CONSTRAINT "SCOPE_STATUS_CHK" CHECK (status IN ('DELETED', 'OPEN', 'CLOSED'))
) PCTFREE 0;


CREATE TABLE did_key_map (
	key VARCHAR2(255 CHAR),
	value VARCHAR2(255 CHAR),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "DID_KEY_MAP_PK" PRIMARY KEY (key, value),
	CONSTRAINT "DID_MAP_KEYS_FK" FOREIGN KEY(key) REFERENCES did_keys (key),
	CONSTRAINT "DID_KEY_MAP_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "DID_KEY_MAP_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL)
) PCTFREE 0;


CREATE TABLE tokens (
	token VARCHAR2(352 CHAR),
	account VARCHAR2(30 CHAR),
	expired_at DATE,
	ip VARCHAR2(39 CHAR),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "TOKENS_PK" PRIMARY KEY (account, token),
	CONSTRAINT "TOKENS_ACCOUNT_FK" FOREIGN KEY(account) REFERENCES accounts (account),
	CONSTRAINT "TOKENS_EXPIRED_AT_NN" CHECK ("EXPIRED_AT" IS NOT NULL),
	CONSTRAINT "TOKENS_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "TOKENS_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL)
) PCTFREE 0;


CREATE TABLE account_map (
	identity VARCHAR2(255 CHAR),
	type VARCHAR(8 CHAR),
	account VARCHAR2(30 CHAR),
	is_default NUMBER(1),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "ACCOUNT_MAP_PK" PRIMARY KEY (identity, type, account),
	CONSTRAINT "ACCOUNT_MAP_ACCOUNT_FK" FOREIGN KEY(account) REFERENCES accounts (account),
	CONSTRAINT "ACCOUNT_MAP_ID_TYPE_FK" FOREIGN KEY(identity, type) REFERENCES identities (identity, type),
	CONSTRAINT "ACCOUNT_MAP_IS_DEFAULT_NN" CHECK (is_default IS NOT NULL),
	CONSTRAINT "ACCOUNT_MAP_TYPE_NN" CHECK ("TYPE" IS NOT NULL),
	CONSTRAINT "ACCOUNT_MAP_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "ACCOUNT_MAP_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL),
	CONSTRAINT "ACCOUNT_MAP_TYPE_CHK" CHECK (type IN ('x509', 'gss', 'userpass')),
	CONSTRAINT "ACCOUNT_MAP_DEFAULT_CHK" CHECK (is_default IN (0, 1))
) PCTFREE 0;


CREATE TABLE dids (
	scope VARCHAR2(30 CHAR),
	name VARCHAR2(255 CHAR),
	account VARCHAR2(30 CHAR),
	type VARCHAR(9 CHAR),
	open NUMBER(1),
	monotonic NUMBER(1) DEFAULT '0',
	hidden NUMBER(1) DEFAULT '0',
	obsolete NUMBER(1) DEFAULT '0',
	complete NUMBER(1),
	new NUMBER(1) DEFAULT '1',
	availability VARCHAR(9 CHAR),
	suppressed NUMBER(1) DEFAULT '0',
	"size" NUMBER(19),
	md5 VARCHAR2(32 CHAR),
	adler32 VARCHAR2(8 CHAR),
	guid RAW(16),
	expired_at DATE,
	updated_at DATE,
	created_at DATE,
	deleted NUMBER(1),
	deleted_at DATE,
	CONSTRAINT "DIDS_ACCOUNT_FK" FOREIGN KEY(account) REFERENCES accounts (account) ON DELETE CASCADE,
	CONSTRAINT "DIDS_SCOPE_FK" FOREIGN KEY(scope) REFERENCES scopes (scope),
	CONSTRAINT "DIDS_MONOTONIC_NN" CHECK ("MONOTONIC" IS NOT NULL),
	CONSTRAINT "DIDS_OBSOLETE_NN" CHECK ("OBSOLETE" IS NOT NULL),
	CONSTRAINT "DIDS_SUPP_NN" CHECK ("SUPPRESSED" IS NOT NULL),
	CONSTRAINT "DIDS_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "DIDS_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL),
	CONSTRAINT "DIDS_DELETED_NN" CHECK (DELETED IS NOT NULL),
	CONSTRAINT "DIDS_TYPE_CHK" CHECK (type IN ('file', 'dataset', 'container')),
	CONSTRAINT "DIDS_OPEN_CHK" CHECK (open IN (0, 1)),
	CONSTRAINT "DIDS_MONOTONIC_CHK" CHECK (monotonic IN (0, 1)),
	CONSTRAINT "DIDS_HIDDEN_CHK" CHECK (hidden IN (0, 1)),
	CONSTRAINT "DIDS_OBSOLETE_CHK" CHECK (obsolete IN (0, 1)),
	CONSTRAINT "DIDS_COMPLETE_CHK" CHECK (complete IN (0, 1)),
	CONSTRAINT "DIDS_NEW_CHK" CHECK (new IN (0, 1)),
	CONSTRAINT "DIDS_AVAILABILITY_CHK" CHECK (availability IN ('lost', 'deleted', 'available')),
	CONSTRAINT "FILES_SUPP_CHK" CHECK (suppressed IN (0, 1)),
	CONSTRAINT "DIDS_DELETED_CHK" CHECK (deleted IN (0, 1))
) PCTFREE 0
PARTITION BY LIST (SCOPE)
(
    PARTITION INITIAL_PARTITION VALUES ('Initial_partition')
);

ALTER TABLE dids ADD CONSTRAINT "DIDS_PK" primary key(scope, name) USING INDEX LOCAL;

ALTER TABLE dids ADD CONSTRAINT "UQ_DIDS_GUID" UNIQUE (guid); -- USING INDEX LOCAL

CREATE INDEX "DIDS_NEW_IDX" ON dids (new) LOCAL;

CREATE INDEX "DIDS_EXPIRED_AT" ON dids (expired_at) LOCAL;


CREATE TABLE replicas (
	rse_id RAW(16),
	scope VARCHAR2(30 CHAR),
	name VARCHAR2(255 CHAR),
	"size" NUMBER(19),
	md5 VARCHAR2(32 CHAR),
	adler32 VARCHAR2(8 CHAR),
	path VARCHAR2(1024 CHAR),
	state VARCHAR(11 CHAR),
	lock_cnt INTEGER,
	accessed_at DATE,
	tombstone DATE,
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "REPLICAS_LFN_FK" FOREIGN KEY(scope, name) REFERENCES dids (scope, name),
	CONSTRAINT "REPLICAS_RSE_ID_FK" FOREIGN KEY(rse_id) REFERENCES rses (id),
	CONSTRAINT "REPLICAS_STATE_NN" CHECK ("STATE" IS NOT NULL),
	CONSTRAINT "REPLICAS_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "REPLICAS_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL),
	CONSTRAINT "REPLICAS_STATE_CHK" CHECK (state IN ('AVAILABLE', 'UNAVAILABLE', 'COPYING', 'BAD'))
) PCTFREE 0
PARTITION BY LIST (RSE_ID)
(
    PARTITION INITIAL_PARTITION VALUES ('00000000000000000000000000000000')
);

ALTER TABLE replicas ADD CONSTRAINT "REPLICAS_PK" primary key(rse_id, scope, name) USING INDEX LOCAL;

CREATE INDEX "REPLICAS_TOMBSTONE_IDX" ON replicas (tombstone) LOCAL;


CREATE TABLE rules (
	id RAW(16),
	subscription_id RAW(16),
	account VARCHAR2(30 CHAR),
	scope VARCHAR2(30 CHAR),
	name VARCHAR2(255 CHAR),
	state VARCHAR(11 CHAR),
	rse_expression VARCHAR2(255 CHAR),
	copies INTEGER,
	expires_at DATE,
	weight VARCHAR2(255 CHAR),
	locked NUMBER(1),
	grouping VARCHAR(7 CHAR),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "RULES_PK" PRIMARY KEY (id),
	CONSTRAINT "RULES_SCOPE_NAME_FK" FOREIGN KEY(scope, name) REFERENCES dids (scope, name),
	CONSTRAINT "RULES_ACCOUNT_FK" FOREIGN KEY(account) REFERENCES accounts (account),
	CONSTRAINT "RULES_SUBS_ID_FK" FOREIGN KEY(subscription_id) REFERENCES subscriptions (id),
	CONSTRAINT "RULES_STATE_NN" CHECK ("STATE" IS NOT NULL),
	CONSTRAINT "RULES_GROUPING_NN" CHECK ("GROUPING" IS NOT NULL),
	CONSTRAINT "RULES_COPIES_NN" CHECK ("COPIES" IS NOT NULL),
	CONSTRAINT "RULES_LOCKED_NN" CHECK ("LOCKED" IS NOT NULL),
	CONSTRAINT uq_rules_scope UNIQUE (scope, name, account, rse_expression, copies),
	CONSTRAINT "RULES_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "RULES_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL),
	CONSTRAINT "RULES_STATE_CHK" CHECK (state IN ('REPLICATING', 'OK', 'STUCK', 'SUSPENDED')),
	CONSTRAINT "RULES_LOCKED_CHK" CHECK (locked IN (0, 1)),
	CONSTRAINT "RULES_GROUPING_CHK" CHECK (grouping IN ('ALL', 'DATASET', 'NONE'))
) PCTFREE 0;


CREATE TABLE requests (
	id RAW(16),
	type VARCHAR(8 CHAR),
	scope VARCHAR2(30 CHAR),
	name VARCHAR2(255 CHAR),
	dest_rse_id RAW(16),
	attributes VARCHAR2(4000 CHAR),
	state VARCHAR(9 CHAR),
	external_id VARCHAR2(64 CHAR),
	retry_count INTEGER,
	err_msg VARCHAR2(4000 CHAR),
	previous_attempt_id RAW(16),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "REQUESTS_PK" PRIMARY KEY (scope, name, dest_rse_id),
	CONSTRAINT "REQUESTS_DID_FK" FOREIGN KEY(scope, name) REFERENCES dids (scope, name),
	CONSTRAINT "REQUESTS_RSES_FK" FOREIGN KEY(dest_rse_id) REFERENCES rses (id),
	CONSTRAINT "REQUESTS_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "REQUESTS_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL),
	CONSTRAINT "REQUESTS_TYPE_CHK" CHECK (type IN ('TRANSFER', 'DELETE', 'UPLOAD', 'DOWNLOAD')),
	CONSTRAINT "REQUESTS_STATE_CHK" CHECK (state IN ('QUEUED', 'SUBMITTED', 'FAILED', 'DONE'))
) PCTFREE 0;

CREATE INDEX "REQUESTS_ID_IDX" ON requests (id);

CREATE INDEX "REQUESTS_TYPE_STATE_IDX" ON requests (type, state);


CREATE TABLE contents (
	scope VARCHAR2(30 CHAR),
	name VARCHAR2(255 CHAR),
	child_scope VARCHAR2(30 CHAR),
	child_name VARCHAR2(255 CHAR),
	type VARCHAR(9 CHAR),
	child_type VARCHAR(9 CHAR),
	"size" NUMBER(19),
	adler32 VARCHAR2(8 CHAR),
	md5 VARCHAR2(32 CHAR),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "CONTENTS_ID_FK" FOREIGN KEY(scope, name) REFERENCES dids (scope, name),
	CONSTRAINT "CONTENTS_CHILD_ID_FK" FOREIGN KEY(child_scope, child_name) REFERENCES dids (scope, name) ON DELETE CASCADE,
	CONSTRAINT "CONTENTS_TYPE_NN" CHECK ("TYPE" IS NOT NULL),
	CONSTRAINT "CONTENTS_CHILD_TYPE_NN" CHECK ("CHILD_TYPE" IS NOT NULL),
	CONSTRAINT "CONTENTS_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "CONTENTS_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL),
	CONSTRAINT "CONTENTS_TYPE_CHK" CHECK (type IN ('file', 'dataset', 'container')),
	CONSTRAINT "CONTENTS_CHILD_TYPE_CHK" CHECK (child_type IN ('file', 'dataset', 'container'))
) PCTFREE 0
PARTITION BY LIST (SCOPE)
(
    PARTITION INITIAL_PARTITION VALUES ('Initial_partition')
);
-- SUBPARTITION BY LIST(CHILD_SCOPE)

ALTER TABLE contents ADD CONSTRAINT "CONTENTS_PK" primary key(scope, name, child_scope, child_name) USING INDEX LOCAL;

CREATE INDEX "CONTENTS_CHILD_SCOPE_NAME_IDX" ON contents (child_scope, child_name) LOCAL;


CREATE TABLE did_attributes (
	scope VARCHAR2(30 CHAR),
	name VARCHAR2(255 CHAR),
	key VARCHAR2(255 CHAR),
	value VARCHAR2(255 CHAR),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "DID_ATTRIBUTES_PK" PRIMARY KEY (scope, name, key),
	CONSTRAINT "DID_ATTR_SCOPE_NAME_FK" FOREIGN KEY(scope, name) REFERENCES dids (scope, name),
	CONSTRAINT "DID_ATTR_SCOPE_FK" FOREIGN KEY(scope) REFERENCES scopes (scope),
	CONSTRAINT "DID_ATTR_KEYS_FK" FOREIGN KEY(key) REFERENCES did_keys (key),
	CONSTRAINT "DID_ATTRIBUTES_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "DID_ATTRIBUTES_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL)
) PCTFREE 0
PARTITION BY LIST (SCOPE)
(
    PARTITION INITIAL_PARTITION VALUES ('Initial_partition')
);

CREATE INDEX "DID_ATTR_KEY_IDX" ON did_attributes (key) LOCAL;


CREATE TABLE locks (
	scope VARCHAR2(30 CHAR),
	name VARCHAR2(255 CHAR),
	rule_id RAW(16),
	rse_id RAW(16),
	account VARCHAR2(30 CHAR),
	"size" NUMBER(19),
	state VARCHAR(11 CHAR),
	updated_at DATE,
	created_at DATE,
	CONSTRAINT "LOCKS_PK" PRIMARY KEY (scope, name, rule_id, rse_id),
	CONSTRAINT "LOCKS_DID_FK" FOREIGN KEY(scope, name) REFERENCES dids (scope, name),
	CONSTRAINT "LOCKS_RULE_ID_FK" FOREIGN KEY(rule_id) REFERENCES rules (id) ON DELETE CASCADE,
	CONSTRAINT "LOCKS_ACCOUNT_FK" FOREIGN KEY(account) REFERENCES accounts (account),
	CONSTRAINT "LOCKS_RSES_FK" FOREIGN KEY(rse_id) REFERENCES rses (id),
	CONSTRAINT "LOCKS_STATE_NN" CHECK ("STATE" IS NOT NULL),
	CONSTRAINT "LOCKS_CREATED_NN" CHECK ("CREATED_AT" IS NOT NULL),
	CONSTRAINT "LOCKS_UPDATED_NN" CHECK ("UPDATED_AT" IS NOT NULL),
	CONSTRAINT "LOCKS_STATE_CHK" CHECK (state IN ('REPLICATING', 'OK', 'STUCK'))
) PCTFREE 0;

CREATE INDEX "LOCKS_ACCOUNT_RSE_ID_IDX" ON locks (account, rse_id);

CREATE INDEX "LOCKS_RULE_ID_IDX" ON locks (rule_id);


CREATE TABLE LOGGING_TABPARTITIONS
(	TABLE_NAME VARCHAR2(30) CONSTRAINT TABPART_TABLE_NN NOT NULL,
	PARTITION_NAME VARCHAR2(40) CONSTRAINT TABPART_PART_NN NOT NULL,
	ACTION_TYPE VARCHAR2(10),
	ACTION_DATE TIMESTAMP(0),
	PART_MARKED_FOR_REMOVAL CHAR(1) CONSTRAINT PART_MARKED_FOR_REMOVAL_YN_CHK CHECK (PART_MARKED_FOR_REMOVAL in ( 'Y', 'N' )),
	MARKED_FOR_REMOVAL_ON DATE,
	REMOVED_ON DATE,
	EXECUTED_SQL_STMT VARCHAR2(1000),
	MESSAGE VARCHAR2(1000)
) PCTFREE 0;


--/
CREATE OR REPLACE PROCEDURE ADD_NEW_PARTITION( m_tabname VARCHAR2, m_partition_name VARCHAR2, m_value VARCHAR2)
AS
	-- PRAGMA AUTONOMOUS_TRANSACTION;
	-- define exception handling for the "ORA-00054: resource busy and acquire with NOWAIT specified" error
	resource_busy EXCEPTION;
	PRAGMA exception_init (resource_busy,-54);
	stmt VARCHAR2(1000);
	v_error_message VARCHAR2(1000);

BEGIN
        LOOP
                BEGIN

			-- the partition name must be enclosed in "" because a dot exists in the name
			stmt := 'ALTER TABLE '|| m_tabname ||' ADD PARTITION "' || substr(m_partition_name,1,30) || '" VALUES  ('''|| m_value ||''')';

			DBMS_UTILITY.exec_ddl_statement(stmt);
			-- EXECUTE IMMEDIATE stmt;
                        INSERT INTO LOGGING_TABPARTITIONS(table_name, partition_name, action_type, action_date, executed_sql_stmt, message )
			VALUES (m_tabname, substr(m_partition_name,1,30) ,'CREATE', systimestamp, stmt, 'success');

                        COMMIT;
                        EXIT;
	      EXCEPTION
	        WHEN  resource_busy THEN
	              -- DBMS_LOCK.sleep(1); -- failed
	               CONTINUE;
		WHEN OTHERS THEN
		      v_error_message := SUBSTR(SQLERRM,1,1000);
		      INSERT INTO LOGGING_TABPARTITIONS(table_name, partition_name, action_type, action_date, executed_sql_stmt, message )
		      VALUES (m_tabname, substr(m_partition_name,1,30),'CREATE', systimestamp, stmt, v_error_message );
		      EXIT;
                END;
	END LOOP;

END;
/

--/
CREATE OR REPLACE TRIGGER create_SCOPE_part_via_PROC
AFTER INSERT on SCOPES
  FOR EACH ROW
DECLARE
	PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
	-- call the procedure for adding partition for a new SCOPE for all relevant tables
	ADD_NEW_PARTITION('DIDS', :new.scope, :new.scope);
	ADD_NEW_PARTITION('DID_ATTRIBUTES', :new.scope, :new.scope);
	ADD_NEW_PARTITION('CONTENTS', :new.scope, :new.scope);
END;
/


 --/
CREATE OR REPLACE TRIGGER create_RSE_part_via_PROC
AFTER INSERT on RSES
  FOR EACH ROW
DECLARE
	PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
	-- call the procedure for adding partition for a new RSE for all relevant tables
	ADD_NEW_PARTITION('REPLICAS', :new.rse, :new.id);
END;
/
